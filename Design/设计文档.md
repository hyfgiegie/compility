

[TOC]

# **参考编译器介绍**

`PL/0`编译系统是一个编译`-`解释执行程序，整个编译过程分两个阶段进行。第一阶段先把`PL/0`源程序编译成假想计算机的目标程序（`P-code`指令），第二阶段再对该目标程序进行解释执行，得到运行结果。`PL/0`编译程序采用一遍扫描，即以语法分析为核心，由它调用词法分析程序取单词，在语法分析过程中同时进行语义分析处理，并生成目标指令。如遇到语法、语义错误，则随时调用出错处理程序，打印出错信息。在编译过程中要利用符号表的登录和查找来进行信息之间的联系。

<img src=".\pics\pl0.png" style="zoom:150%;" />

# **总体设计介绍**

整体分为前端，中端和后端三部分。

前端由词法分析器`(Lexer)`、语法分析器`(Parser)`组成，主要是对输入的字符串进行预处理，建立出语法树。

中端包括语义分析器`(Visitor)`，符号表管理`(SymbolManager)`，集中进行错误处理并利用前端生成的语法树来生成中间代码，通过优化器`(Optimizer)`进行中间代码优化处理，将中间代码放入到中间代码容器中，通过解释执行程序`(VirtualMachine)`生成`LLVM`代码

后端包括目标翻译器`(Translater)`和存储管理`(ActivityRecord)`，将中间代码翻译成目标代码，即` MIPS` 代码，至此完成一个编译的基本过程。

![](.\pics\general.JPG)

# 一、**词法分析阶段设计**

#### 1、单词类别码定义

| 单词名称     | 类别码     | 单词名称 | 类别码   | 单词名称 | 类别码 | 单词名称 | 类别码  |
| ------------ | ---------- | -------- | -------- | -------- | ------ | -------- | ------- |
| Ident        | IDENFR     | !        | NOT      | *        | MULT   | =        | ASSIGN  |
| IntConst     | INTCON     | &&       | AND      | /        | DIV    | ;        | SEMICN  |
| FormatString | STRCON     | \|\|     | OR       | %        | MOD    | ,        | COMMA   |
| main         | MAINTK     | for      | FORTK    | <        | LSS    | (        | LPARENT |
| const        | CONSTTK    | getint   | GETINTTK | <=       | LEQ    | )        | RPARENT |
| int          | INTTK      | printf   | PRINTFTK | >        | GRE    | [        | LBRACK  |
| break        | BREAKTK    | return   | RETURNTK | >=       | GEQ    | ]        | RBRACK  |
| continue     | CONTINUETK | +        | PLUS     | ==       | EQL    | {        | LBRACE  |
| if           | IFTK       | -        | MINU     | !=       | NEQ    | }        | RBRACE  |
| else         | ELSETK     | void     | VOIDTK   |          |        |          |         |

#### 2、`Token`类设计

`Token`类是存放被读取到的一个词法单元的类，其类图如下：

<img src="./pics/Token.jpg" style="zoom:75%;" />

其中`type`属性用来存储类别码，`value`属性用来存储具体的值

#### 3、`Lexer`类设计

`Lexer`类是用于分析词法的主类，其类图如下：

<img src=".\pics\Lexer.JPG" style="zoom:80%;" />

在`Lexer`类中，主方法是`parseText()`，当文本词法正确时返回`true`，否则返回`false`:

```java
public boolean parseText() {
        skipWhite();
        while (parseUnit()) {
            skipWhite();
        }
        return errorContent.length() == 0;
    }
```

在`parseUint()`类中，解析并存放一个词法单元到`tokenList`中，如果出现词法错误，则返回`false`并保存错误信息到`errorContent`：

```java
private boolean parseUnit() {
        skipWhite();
        tokenUnit = new StringBuffer();

        int ch = read();
        if (ch == -1) {
            //end of text
            return false;
        } else if (isLetter(ch) || ch == '_') {
            tokenUnit.append((char) ch);
            parseIdent();
            String type = signalTable.getSym(tokenUnit.toString());
            if (type == null) tokenList.add(new Token("IDENFR", tokenUnit.toString()));
            else tokenList.add(new Token(type, tokenUnit.toString()));
        } else if (isNum(ch)) {
            tokenUnit.append((char) ch);
            parseNum();
            tokenList.add(new Token("INTCON", tokenUnit.toString()));
        } else if (ch == '"') {
            tokenUnit.append((char) ch);
            parseString();
            if (tokenUnit.length() < 2) {
                //error
                errorContent = "There is an unknown signal " + tokenUnit.toString() + " in lines-" + lines;
                return false;
            } else if (tokenUnit.charAt(tokenUnit.length() - 1) != '"') {
                errorContent = "There is an unfinished formatString in lines-" + lines;
                return false;
            }
            tokenList.add(new Token("STRCON", tokenUnit.toString()));
        } else if (isLegalSig(ch)) {
            tokenUnit.append((char) ch);
            parseSignal();
            String type = signalTable.getSym(tokenUnit.toString());

            //not comments
            if (!tokenUnit.toString().equals("//") &&
                    !tokenUnit.toString().equals("/*")) {
                if (type != null) tokenList.add(new Token(type, tokenUnit.toString()));
                else {
                    //means error of single | or &
                    errorContent = "There is an unknown signal " + tokenUnit.toString() + " in lines-" + lines;
                    return false;
                }
            }
        } else {
            //error of un-known signal
            errorContent = "There is an unknown signal " + (char) ch + " in lines-" + lines;
            return false;
        }
        return true;
    }
```

其主要的状态流程图如下所示：

![](.\pics\LexerState.JPG)

在主类`Complier`中新建`Lexer`类，将文本信息通过数组形式传入到`Lexer`类中，调用`parseText()`方法，即可完成对文本信息的词法解析，如果解析正确则可通过`getTokenList()`方法得到文本词法解析结果，否则可以通过`getErrorContent()`方法得到文本词法错误信息

# 二、**语法分析阶段设计**

#### 1、语法规则

```c++
编译单元 CompUnit → {Decl} {FuncDef} MainFuncDef 
声明 Decl → ConstDecl 
		 | VarDecl 
常量声明 ConstDecl → 'const' BType ConstDef { ',' ConstDef } ';' 
基本类型 BType → 'int' 
常数定义 ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal 
常量初值 ConstInitVal → ConstExp
				    | '{' [ ConstInitVal { ',' ConstInitVal } ] '}' 
变量声明 VarDecl → BType VarDef { ',' VarDef } ';' 
变量定义 VarDef → Ident { '[' ConstExp ']' } 
			  | Ident { '[' ConstExp ']' } '=' InitVal
变量初值 InitVal → Exp 
			   | '{' [ InitVal { ',' InitVal } ] '}'
函数定义 FuncDef → FuncType Ident '(' [FuncFParams] ')' Block 
主函数定义 MainFuncDef → 'int' 'main' '(' ')' Block 
函数类型 FuncType → 'void' 
				| 'int' 
函数形参表 FuncFParams → FuncFParam { ',' FuncFParam } 
函数形参 FuncFParam → BType Ident ['[' ']' { '[' ConstExp ']' }] 
语句块 Block → '{' { BlockItem } '}' 
语句块项 BlockItem → Decl 
				 | Stmt 
语句 Stmt → LVal '=' Exp ';' 
		 | [Exp] ';' 
		 | Block
		 | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 
		 | 'for' '(' [ForStmt] ';' [Cond] ';' [forStmt] ')' Stmt
		 | 'break' ';' | 'continue' ';'
		 | 'return' [Exp] ';' 
		 | LVal '=' 'getint''('')'';'
		 | 'printf''('FormatString{','Exp}')'';' 
语句 ForStmt → LVal '=' Exp
表达式 Exp → AddExp 注：SysY 表达式是int 型表达式 
条件表达式 Cond → LOrExp 
左值表达式 LVal → Ident {'[' Exp ']'} 
基本表达式 PrimaryExp → '(' Exp ')' 
				    | LVal 
				    | Number 
数值 Number → IntConst 
一元表达式 UnaryExp → PrimaryExp 
				  | Ident '(' [FuncRParams] ')' 
				  | UnaryOp UnaryExp 
单目运算符 UnaryOp → '+' | '−' | '!' 注：'!'仅出现在条件表达式中 
函数实参表 FuncRParams → Exp { ',' Exp } 
乘除模表达式 MulExp → UnaryExp 
				 | MulExp ('*' | '/' | '%') UnaryExp 
加减表达式 AddExp → MulExp 
				| AddExp ('+' | '−') MulExp 
关系表达式 RelExp → AddExp 
				| RelExp ('<' | '>' | '<=' | '>=') AddExp 
相等性表达式 EqExp → RelExp 
				| EqExp ('==' | '!=') RelExp 
逻辑与表达式 LAndExp → EqExp 
				  | LAndExp '&&' EqExp 
逻辑或表达式 LOrExp → LAndExp 
				 | LOrExp '||' LAndExp 
常量表达式 ConstExp → AddExp 注：使用的Ident 必须是常量 

```

#### 2、`Factor`类设计

在语法分析阶段需要通过分析一段`Token`的序列来根据上述的文法规则建立起一棵以`CompUnit`为根节点的语法树，因此设计`Factor`类作来存储每个子节点的具体信息，其类图如下：

<img src="./pics/Factor.jpg" style="zoom:75%;" />

其中`type`属性用于存储该节点的名称，特别的，若该节点为叶节点，则其名称为`Token`，此时其`token`属性存放被分析到的对应的`token`值，若为非叶节点，则`token`属性保持为`null`。

#### 3、`Parser`类设计

`Parser`类是语法分析器类，主要对词法分析阶段得到的`tokens`序列进行进一步解析，从而生成语法树

<img src="./pics/Parser.png" style="zoom:50%;" />

对于每一种非终结符，都有其对应的`parse()`方法，主体思路是递归下降分析法，由于自顶向下分析不能适用于左递归文法，所以对左递归的文法规则进行了如下调整：

```c++
乘除模表达式 MulExp → UnaryExp { ('*' | '/' | '%') UnaryExp }
加减表达式 AddExp → MulExp { ('+' | '−') MulExp } 
关系表达式 RelExp → AddExp { ('<' | '>' | '<=' | '>=') AddExp }
相等性表达式 EqExp → RelExp { ('==' | '!=') RelExp }
逻辑与表达式 LAndExp → EqExp { '&&' EqExp }
逻辑或表达式 LOrExp → LAndExp { '||' LAndExp }
```

但为了最终使用深度优先搜索算法对语法树进行输出时与左递归文法保持一致，我每次读取到新的语法单元都会和上一次已经得到的语法单元进行合并，生成一个新的节点，这样就可以保证最终生成的语法树符合左递归文法，以`LOrExp`的解析方法为例：

```java
private Factor parseLOrExp() {
        Factor lOrExp = new Factor("LOrExp");
        lOrExp.addChild(parseLAndExp());
        Factor ret = lOrExp;
        while (getCurToken().getValue().equals("||")) {
            ret = new Factor("LOrExp");
            ret.addChild(lOrExp);
            ret.addChild(new Factor(getCurToken()));
            position++;
            ret.addChild(parseLAndExp());
            lOrExp = ret;
        }
        return ret;
    }
```

对于向下解析时会有多种选择的非终结符，如`Stmt`，采用先分析每种选择的`FIRST`集的方法：

```c++
语句 Stmt → LVal '=' Exp ';'	// {'Ident'}
		 | [Exp] ';'	// {'(' , 'Number' , 'Ident' , '+' , '-' ,'!'}
		 | Block	// {'{'}
		 | 'if' '(' Cond ')' Stmt [ 'else' Stmt ]	// {'if'}
		 | 'for' '(' [ForStmt] ';' [Cond] ';' [forStmt] ')' Stmt	// {'for'}
		 | 'break' ';'	// {'break'}
		 | 'continue' ';'	// {'continue'}
		 | 'return' [Exp] ';'	// {'return'}
		 | LVal '=' 'getint''('')'';'	// {'Ident'}
		 | 'printf''('FormatString{','Exp}')'';'	// {'printf'} 
```

可以看到，如果当前`token`不是`Ident`时，都会有对应的唯一的选择，如果是`Ident`，则会出现三种情况，此时不可避免要采用回溯的办法：

```c++
语句 Stmt → LVal '=' Exp ';'
		 | [Exp] ';'
		 | LVal '=' 'getint''('')'';'
```

由于`Exp`可以推出`LVal`，所以一种朴素的思想是，我可以尝试解析`Exp`，当解析完成后再分析下一个符号是`=`还是`;`，如果是前一种情况，那么可以判断是第一种、第三种推导方式，否则是第二种推导方式，此时再进行回溯按照正确的规则重新推导即可